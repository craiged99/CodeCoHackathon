import pandas as pdimport numpy as np#Function that outputs a data anomaly for players 'energies' (biggest distance covered drop-off)def energy(match,splits,minute,period,home_or_away):        '''    This smaller dataset is the same as the original tracking with less points (2 frames per    second rather than 25)    '''        test1 = pd.read_json('smaller_data_'+ match +'.json')        if period ==1:        acutal_time = minute*60+0.5        test1 = test1[(test1['gameClock'] < acutal_time) & (test1['period'] == 1)]    if period == 2:        acutal_time = (minute-45)*60+0.5        test1 = test1[(test1['gameClock'] < acutal_time) | (test1['period'] == 1)]               full_file = pd.read_json("MCI Women's Files/"+match+"_SecondSpectrum_meta.json", orient='index')        players_file = full_file.loc[str(home_or_away)+'Players']        players_dict = {}    players_distance = {}    players_ids = []        for i in range(len(players_file[0])):                list_name = players_file[0][i]['ssiId']        players_dict[list_name] = 0        players_distance[list_name] = 0        players_ids.append(list_name)        #players = pd.read_json("MCI Women's Files/g2312135_SecondSpectrum_meta.json")            home_players = test1[str(home_or_away)+'Players']    end_players_list = test1[str(home_or_away)+'Players'].iloc[-1]        end_players_ids = []        for i in range(len(end_players_list)):                list_name = end_players_list[i]['playerId']            end_players_ids.append(list_name)                        start_min = minute-10    start_players = test1[(round(test1['gameClock']) == start_min) & (test1['period'] == period)].iloc[0][str(home_or_away)+'Players']            start_players_ids = []        for i in range(len(start_players)):                list_name = start_players[i]['playerId']            start_players_ids.append(list_name)            players_full = [i for i, j in zip(start_players_ids, end_players_ids) if i == j]            mins_to_save = np.linspace(int(60*splits),5400,int(90/splits))            distance_10s = pd.DataFrame(columns = mins_to_save)        for i in range(len(home_players)):                if test1.iloc[i]['period'] == 1:            extra = 0        else:            extra = 2700                frame = home_players.iloc[i]                if test1.iloc[i]['gameClock'] == 0.0:            for j in range(len(frame)):                player = frame[j]['playerId']                x_pos = frame[j]['xyz'][0]                y_pos = frame[j]['xyz'][1]                players_dict[player] = [x_pos,y_pos]                                        else:            for j in range(len(frame)):                                                player = frame[j]['playerId']                                x_pos = frame[j]['xyz'][0]                y_pos = frame[j]['xyz'][1]                                try:                    old_pos_x = players_dict[player][0]                    old_pos_y = players_dict[player][1]                except:                    old_pos_x = x_pos                    old_pos_y = y_pos                                    players_dict[player] = [x_pos,y_pos]                                distance = np.sqrt((x_pos-old_pos_x)**2+(y_pos-old_pos_y)**2)                                players_distance[player] = players_distance[player]+distance                    for p in range(len(mins_to_save)):                        if test1.iloc[i]['gameClock']+extra >= mins_to_save[p]+0 and test1.iloc[i]['gameClock']+extra <= mins_to_save[p]+0.49:                                vals = list(players_distance.values())                    distance_10s[round(test1.iloc[i]['gameClock']+extra)] = vals                            keys = list(players_distance.keys())        distance_10s.index = keys        perc_distance = pd.DataFrame()        for j in range(len(distance_10s)):        player_vals = distance_10s.iloc[j]        player = distance_10s.index[j]                values = []        values_perc = []        for i in range(len(player_vals)):                                    if i > 0:                old = player_vals.iloc[i-1]                new = player_vals.iloc[i]                values.append(new-old)                            else:                values.append(player_vals.iloc[i])                    if i > 0 and values[i-1] != 0:                previous_10 = values[i-1]                current_10 = values[i]                values_perc.append(((current_10/previous_10)*100)-100)                            else:                 values_perc.append(0)            perc_distance[player] = values_perc            perc_distance = perc_distance.transpose()    perc_distance.columns = mins_to_save        energy_splits = perc_distance.dropna(axis=1, how='any')    energy_splits = energy_splits[energy_splits.columns[-1]]    energy_splits = energy_splits[energy_splits!=0]    energy_splits = energy_splits.loc[players_full]    avg_energy = np.average(energy_splits)    energy_splits = energy_splits.sort_values()    worst_player  = energy_splits.keys()[0]    worst_val = energy_splits.values[0]        #Ignore goalkeepers (hard-codedd for the MCWFC, AWFC goalkeepers)        if worst_player == 'E. Roebuck' or worst_player == 'M. Zinsberger':        worst_player  = energy_splits.keys()[1]        worst_val = energy_splits.values[1]            anomaly_score = round(abs((worst_val-avg_energy)*2)/10)        final_dict = {'player':worst_player,'worst_val':worst_val,'anomaly_score':anomaly_score,'avg_val':avg_energy}        return energy_splits,final_dict                    